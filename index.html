<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Decode Her Anger - Dynamic Hugging Face Edition</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f9f9f9;
      margin: 20px;
      color: #333;
    }
    h1, h2 {
      text-align: center;
    }
    #landing, #girlfriendSection, #boyfriendSection {
      max-width: 600px;
      margin: 20px auto;
      padding: 20px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      text-align: center;
    }
    textarea {
      width: 100%;
      height: 80px;
      margin: 10px 0;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: none;
    }
    button {
      padding: 10px 15px;
      font-size: 16px;
      margin: 5px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      background: #0077cc;
      color: #fff;
    }
    button:hover {
      background: #005fa3;
    }
    .optionBtn {
      display: block;
      width: 90%;
      margin: 10px auto;
      text-align: left;
    }
    #questionContainer, #resultSection, #noAngerMsg {
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <!-- Landing Page -->
  <div id="landing">
    <h1>Don't know why your girlfriend is mad?</h1>
    <p>"Don't know why she's mad? You're at the right place! She already told us why. You just have to decode it!"</p>
    <button id="gfBtn">I'm the Girlfriend</button>
    <button id="bfBtn">I'm the Boyfriend</button>
  </div>

  <!-- Girlfriend Section -->
  <div id="girlfriendSection" style="display:none;">
    <h2>Girlfriend: Tell us what's wrong</h2>
    <textarea id="angerInput" placeholder="Why are you mad?"></textarea>
    <textarea id="punishmentInput" placeholder="Punishment if he fails to decode"></textarea>
    <button id="submitAnger">Submit</button>
  </div>

  <!-- Boyfriend Section -->
  <div id="boyfriendSection" style="display:none;">
    <h2>Decode Her Anger</h2>
    <div id="noAngerMsg" style="display:none;">
      <p>She's not mad right now â€“ enjoy the silence before the storm!</p>
    </div>
    <div id="questionContainer" style="display:none;">
      <p id="questionText"></p>
      <div id="options"></div>
      <p>Question Count: <span id="questionCount">0</span> / 11</p>
    </div>
    <div id="resultSection" style="display:none;">
      <p id="resultText"></p>
    </div>
  </div>

  <script>
    // --- Element References ---
    const gfBtn = document.getElementById('gfBtn');
    const bfBtn = document.getElementById('bfBtn');
    const landing = document.getElementById('landing');
    const girlfriendSec = document.getElementById('girlfriendSection');
    const boyfriendSec = document.getElementById('boyfriendSection');

    // Girlfriend inputs
    const angerInput = document.getElementById('angerInput');
    const punishmentInput = document.getElementById('punishmentInput');
    const submitAnger = document.getElementById('submitAnger');

    // Boyfriend decoding elements
    const noAngerMsg = document.getElementById('noAngerMsg');
    const questionContainer = document.getElementById('questionContainer');
    const questionText = document.getElementById('questionText');
    const optionsDiv = document.getElementById('options');
    const questionCountDisplay = document.getElementById('questionCount');
    const resultSection = document.getElementById('resultSection');
    const resultText = document.getElementById('resultText');

    // --- Game Variables ---
    let conversationLog = "";
    let questionCount = 0;
    const maxQuestions = 11;
    let currentQuestion = null;
    // Our Hugging Face API key (inserted everywhere)
    const hfApiKey = "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";
    // Using Hugging Face Inference API endpoint (we use distilgpt2; adjust model as needed)
    const hfApiUrl = "https://api-inference.huggingface.co/models/distilgpt2";

    // --- Landing Page Logic ---
    gfBtn.addEventListener('click', () => {
      landing.style.display = 'none';
      girlfriendSec.style.display = 'block';
    });

    bfBtn.addEventListener('click', () => {
      landing.style.display = 'none';
      boyfriendSec.style.display = 'block';
      const storedReason = localStorage.getItem('angerReason');
      if (!storedReason) {
        noAngerMsg.style.display = 'block';
      } else {
        startDecoding();
      }
    });

    // --- Girlfriend Submission ---
    submitAnger.addEventListener('click', () => {
      const anger = angerInput.value.trim();
      const punishment = punishmentInput.value.trim();
      if (anger === '' || punishment === '') {
        alert("Please fill in both fields.");
        return;
      }
      localStorage.setItem('angerReason', anger);
      localStorage.setItem('punishment', punishment);
      alert("Your input has been recorded!");
      girlfriendSec.style.display = 'none';
      landing.style.display = 'block';
    });

    // --- Functions to Call Hugging Face API ---

    // Generates a dynamic multiple-choice question
    async function generateQuestionHF(reasonText, log) {
      const prompt = `Context:
Anger Reason: "${reasonText}"
Conversation Log: "${log}"
Generate a multiple-choice question (with 4 options) that helps the boyfriend decode why she is mad.
Return the result as a JSON object with keys:
  - "question": a string.
  - "options": an array of 4 strings.
There is no absolute "correct" answer; instead, your answer evaluation will be based on closeness to the reason.
Do not output extra text.`;

      try {
        const response = await fetch(hfApiUrl, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${hfApiKey}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            inputs: prompt,
            parameters: { max_new_tokens: 150, temperature: 0.7 }
          })
        });
        if (!response.ok) {
          throw new Error("Hugging Face API error");
        }
        const data = await response.json();
        // Assume the generated text is our JSON object
        const generatedText = data[0].generated_text.trim();
        const questionObj = JSON.parse(generatedText);
        return questionObj;
      } catch (error) {
        console.error("Error generating question:", error);
        // Fallback default question
        return {
          question: "Do you think you overlooked something important?",
          options: ["I have a good memory", "Maybe I missed a detail", "I am sure I did nothing wrong", "Not sure at all"]
        };
      }
    }

    // Evaluates the boyfriend's answer against the anger reason
    async function evaluateAnswerHF(reasonText, log, selectedOption) {
      const prompt = `Context:
Anger Reason: "${reasonText}"
Conversation Log: "${log}"
The boyfriend answered: "${selectedOption}".
Based on the context, determine if the boyfriend's answer is "on point" (i.e. close enough to decoding why she is mad).
Return a valid JSON object with one key:
  - "onPoint": either true or false.
Do not output extra text.`;

      try {
        const response = await fetch(hfApiUrl, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${hfApiKey}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            inputs: prompt,
            parameters: { max_new_tokens: 50, temperature: 0.7 }
          })
        });
        if (!response.ok) {
          throw new Error("Hugging Face API error");
        }
        const data = await response.json();
        const generatedText = data[0].generated_text.trim();
        const evalObj = JSON.parse(generatedText);
        return evalObj;
      } catch (error) {
        console.error("Error evaluating answer:", error);
        // Fallback: consider the answer not on point
        return { onPoint: false };
      }
    }

    // --- Game Flow Functions ---

    // Starts the decoding process
    async function startDecoding() {
      const reason = localStorage.getItem('angerReason');
      conversationLog = `Anger Reason provided: "${reason}". `;
      questionCount = 0;
      updateQuestionCount();
      resultSection.style.display = 'none';
      questionContainer.style.display = 'block';
      await loadNextQuestion();
    }

    // Loads the next dynamic question
    async function loadNextQuestion() {
      const reason = localStorage.getItem('angerReason');
      currentQuestion = await generateQuestionHF(reason, conversationLog);
      conversationLog += `Generated question: "${currentQuestion.question}". `;
      displayQuestion(currentQuestion);
    }

    // Displays the current question and its options
    function displayQuestion(qObj) {
      if (!qObj) {
        decodeFailure();
        return;
      }
      questionText.textContent = qObj.question;
      optionsDiv.innerHTML = "";
      qObj.options.forEach((option, index) => {
        const btn = document.createElement('button');
        btn.textContent = option;
        btn.classList.add('optionBtn');
        btn.addEventListener('click', () => handleAnswer(option));
        optionsDiv.appendChild(btn);
      });
    }

    // Handles the boyfriend's answer
    async function handleAnswer(selectedOption) {
      conversationLog += `Boyfriend answered: "${selectedOption}". `;
      // Evaluate the answer using the HF API
      const reason = localStorage.getItem('angerReason');
      const evalResult = await evaluateAnswerHF(reason, conversationLog, selectedOption);
      questionCount++;
      updateQuestionCount();

      if (evalResult.onPoint === true) {
        // If onPoint, decoding is successful
        decodeSuccess();
      } else if (questionCount >= maxQuestions) {
        // Exceeded maximum questions without onPoint answer
        decodeFailure();
      } else {
        // Otherwise, load next question
        await loadNextQuestion();
      }
    }

    function updateQuestionCount() {
      questionCountDisplay.textContent = questionCount;
    }

    // --- Game End Functions ---

    function decodeSuccess() {
      questionContainer.style.display = 'none';
      resultSection.style.display = 'block';
      const reason = localStorage.getItem('angerReason');
      resultText.textContent = "Success! You decoded her anger. She is mad because: " + reason;
    }

    function decodeFailure() {
      questionContainer.style.display = 'none';
      resultSection.style.display = 'block';
      const punishment = localStorage.getItem('punishment');
      resultText.textContent = "Decoding failed. Your punishment: " + punishment;
    }
  </script>
</body>
</html>
