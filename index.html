<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Decode Her Anger - Dynamic Free-Text Edition (Improved)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f9f9f9;
      margin: 20px;
      color: #333;
    }
    h1, h2 {
      text-align: center;
    }
    #landing, #girlfriendSection, #boyfriendSection {
      max-width: 600px;
      margin: 20px auto;
      padding: 20px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      text-align: center;
    }
    textarea, input[type="text"] {
      width: 100%;
      margin: 10px 0;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    textarea {
      height: 80px;
      resize: none;
    }
    button {
      padding: 10px 15px;
      font-size: 16px;
      margin: 5px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      background: #0077cc;
      color: #fff;
    }
    button:hover {
      background: #005fa3;
    }
    #questionContainer, #resultSection, #noAngerMsg {
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <!-- Landing Page -->
  <div id="landing">
    <h1>Don't know why your girlfriend is mad?</h1>
    <p>"Don't know why she's mad? You're at the right place! She already told us why. You just have to decode it!"</p>
    <button id="gfBtn">I'm the Girlfriend</button>
    <button id="bfBtn">I'm the Boyfriend</button>
  </div>

  <!-- Girlfriend Section -->
  <div id="girlfriendSection" style="display:none;">
    <h2>Girlfriend: Tell us what's wrong</h2>
    <textarea id="angerInput" placeholder="Why are you mad?"></textarea>
    <textarea id="punishmentInput" placeholder="Punishment if he fails to decode"></textarea>
    <button id="submitAnger">Submit</button>
  </div>

  <!-- Boyfriend Section -->
  <div id="boyfriendSection" style="display:none;">
    <h2>Decode Her Anger</h2>
    <div id="noAngerMsg" style="display:none;">
      <p>She's not mad right now â€“ enjoy the silence before the storm!</p>
    </div>
    <div id="questionContainer" style="display:none;">
      <p id="questionText"></p>
      <!-- Free-text input for boyfriend's answer -->
      <input type="text" id="bfAnswerInput" placeholder="Type your answer here">
      <button id="submitBFAnswer">Submit Answer</button>
      <p>Question Count: <span id="questionCount">0</span> / 11</p>
    </div>
    <div id="resultSection" style="display:none;">
      <p id="resultText"></p>
    </div>
  </div>

  <script>
    /*******************************
    * Cautionary Comments:
    * - This version uses the Hugging Face Inference API with a higher temperature (0.9) to encourage diverse outputs.
    * - If the generated question is identical to the previous one, the code will retry (up to 3 attempts) before accepting it.
    * - The conversation log is updated on each API call to influence future question generation.
    * - The game ends if the boyfriend goes through more than 11 questions without the evaluation returning "onPoint": true.
    *******************************/

    // --- Element References ---
    const gfBtn = document.getElementById('gfBtn');
    const bfBtn = document.getElementById('bfBtn');
    const landing = document.getElementById('landing');
    const girlfriendSec = document.getElementById('girlfriendSection');
    const boyfriendSec = document.getElementById('boyfriendSection');

    // Girlfriend inputs
    const angerInput = document.getElementById('angerInput');
    const punishmentInput = document.getElementById('punishmentInput');
    const submitAnger = document.getElementById('submitAnger');

    // Boyfriend decoding elements
    const noAngerMsg = document.getElementById('noAngerMsg');
    const questionContainer = document.getElementById('questionContainer');
    const questionText = document.getElementById('questionText');
    const bfAnswerInput = document.getElementById('bfAnswerInput');
    const submitBFAnswer = document.getElementById('submitBFAnswer');
    const questionCountDisplay = document.getElementById('questionCount');
    const resultSection = document.getElementById('resultSection');
    const resultText = document.getElementById('resultText');

    // --- Game Variables ---
    let conversationLog = "";
    let questionCount = 0;
    const maxQuestions = 11;
    let currentQuestion = null;
    let previousQuestion = "";
    // Hugging Face API key (inserted everywhere)
    const hfApiKey = "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";
    // Hugging Face Inference API endpoint using distilgpt2; you can change the model if needed.
    const hfApiUrl = "https://api-inference.huggingface.co/models/distilgpt2";

    // --- Landing Page Logic ---
    gfBtn.addEventListener('click', () => {
      landing.style.display = 'none';
      girlfriendSec.style.display = 'block';
    });

    bfBtn.addEventListener('click', () => {
      landing.style.display = 'none';
      boyfriendSec.style.display = 'block';
      const storedReason = localStorage.getItem('angerReason');
      if (!storedReason) {
        noAngerMsg.style.display = 'block';
      } else {
        startDecoding();
      }
    });

    // --- Girlfriend Submission ---
    submitAnger.addEventListener('click', () => {
      const anger = angerInput.value.trim();
      const punishment = punishmentInput.value.trim();
      if (anger === '' || punishment === '') {
        alert("Please fill in both fields.");
        return;
      }
      localStorage.setItem('angerReason', anger);
      localStorage.setItem('punishment', punishment);
      alert("Your input has been recorded!");
      girlfriendSec.style.display = 'none';
      landing.style.display = 'block';
    });

    // --- Function to Call Hugging Face API to Generate a Question ---
    async function generateQuestionHF(reasonText, log, retryCount = 0) {
      const prompt = `Context:
Anger Reason: "${reasonText}"
Conversation Log: "${log}"
Generate a unique decoding question to help the boyfriend figure out why she is mad.
Return a valid JSON object with one key:
  - "question": a string containing the question.
Do not include any extra text.`;
      
      try {
        const response = await fetch(hfApiUrl, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${hfApiKey}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            inputs: prompt,
            parameters: { max_new_tokens: 100, temperature: 0.9 }
          })
        });
        if (!response.ok) {
          throw new Error("Hugging Face API error");
        }
        const data = await response.json();
        const generatedText = data[0].generated_text.trim();
        const questionObj = JSON.parse(generatedText);
        // Check for duplicate question
        if (questionObj.question === previousQuestion && retryCount < 3) {
          console.warn("Duplicate question detected. Retrying...");
          return await generateQuestionHF(reasonText, log, retryCount + 1);
        }
        previousQuestion = questionObj.question;
        return questionObj;
      } catch (error) {
        console.error("Error generating question:", error);
        // Fallback default question if API fails
        return { question: "Could it be that you overlooked something important?" };
      }
    }

    // --- Function to Call Hugging Face API to Evaluate Boyfriend's Answer ---
    async function evaluateAnswerHF(reasonText, log, answerText) {
      const prompt = `Context:
Anger Reason: "${reasonText}"
Conversation Log: "${log}"
The boyfriend answered: "${answerText}".
Determine if this answer is "on point" (i.e., sufficiently close to decoding why she is mad).
Return a valid JSON object with one key:
  - "onPoint": either true or false.
Do not include any extra text.`;
      
      try {
        const response = await fetch(hfApiUrl, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${hfApiKey}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            inputs: prompt,
            parameters: { max_new_tokens: 50, temperature: 0.9 }
          })
        });
        if (!response.ok) {
          throw new Error("Hugging Face API error");
        }
        const data = await response.json();
        const generatedText = data[0].generated_text.trim();
        const evalObj = JSON.parse(generatedText);
        return evalObj;
      } catch (error) {
        console.error("Error evaluating answer:", error);
        // Fallback: assume answer is not on point
        return { onPoint: false };
      }
    }

    // --- Game Flow Functions ---
    async function startDecoding() {
      const reason = localStorage.getItem('angerReason');
      conversationLog = `Anger Reason provided: "${reason}". `;
      questionCount = 0;
      updateQuestionCount();
      resultSection.style.display = 'none';
      questionContainer.style.display = 'block';
      bfAnswerInput.value = "";
      await loadNextQuestion();
    }

    async function loadNextQuestion() {
      const reason = localStorage.getItem('angerReason');
      currentQuestion = await generateQuestionHF(reason, conversationLog);
      conversationLog += `Generated question: "${currentQuestion.question}". `;
      displayQuestion(currentQuestion);
    }

    function displayQuestion(qObj) {
      if (!qObj || !qObj.question) {
        decodeFailure();
        return;
      }
      questionText.textContent = qObj.question;
      bfAnswerInput.value = "";
    }

    submitBFAnswer.addEventListener('click', async () => {
      const answerText = bfAnswerInput.value.trim();
      if (answerText === "") {
        alert("Please type an answer.");
        return;
      }
      conversationLog += `Boyfriend answered: "${answerText}". `;
      const reason = localStorage.getItem('angerReason');
      const evalResult = await evaluateAnswerHF(reason, conversationLog, answerText);
      questionCount++;
      updateQuestionCount();
      
      if (evalResult.onPoint === true) {
        decodeSuccess();
      } else if (questionCount >= maxQuestions) {
        decodeFailure();
      } else {
        await loadNextQuestion();
      }
    });

    function updateQuestionCount() {
      questionCountDisplay.textContent = questionCount;
    }

    // --- Game End Functions ---
    function decodeSuccess() {
      questionContainer.style.display = 'none';
      resultSection.style.display = 'block';
      const reason = localStorage.getItem('angerReason');
      resultText.textContent = "Success! You decoded her anger. She is mad because: " + reason;
    }

    function decodeFailure() {
      questionContainer.style.display = 'none';
      resultSection.style.display = 'block';
      const punishment = localStorage.getItem('punishment');
      resultText.textContent = "Decoding failed. Your punishment: " + punishment;
    }
  </script>
</body>
</html>
